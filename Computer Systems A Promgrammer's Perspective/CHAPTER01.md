# CHAPTER01 : 컴퓨터 시스템으로의 여행(A Tour of Computer Systems)
- 컴퓨터 시스템
    - 하드웨어와 시스템 소프트웨어로 구성
        - 이들은 함께 작동하여 응용 프로그램을 실행
    - 모든 컴퓨터 시스템들은 유사한 기능을 수행하는 유사한 하드웨어와 소프트웨어 컴포넌트를 보유

## 1.1 정보는 비트와 컨텍스트로 이루어진다
- hello 프로그램
    - 프로그래머가 에디터로 작성한 소스 프로그램(또는 소스파일)으로 생명을 시작
        - 소스 프로그램
            - 0 또는 1로 표시되는 비트들의 연속이며, 바이트라는 8비트 단위로 구성
            - 각 바이트는 프로그램의 텍스트 문자를 표시
    - hello.c라는 텍스트 파일로 저장
- 대부분의 컴퓨터 시스템 텍스트 문자를 아스키(ASCII) 표준을 사용하여 표시
    - 아스키 표준
        - 각 문자를 바이트 길이의 정수 값으로 표시
    - 택스트 파일
        - 오로지 아스키 문자들로만 이루어진 파일들
    - 바이너리 파일
        - 텍스트 파일이 아닌 다른 모든 파일들
- 모든 시스템 내부의 정보
    - 디스크 파일, 메모리상의 프로그램, 데이터, 네트워크를 통해 전송되는 데이터가 존재
        - 비트들로 표시

## 추가정보 1. C 프로그래밍 언어의 기원
- 1969년부터 1973년까지 벨 연구소의 Dennis Ritchie에 의해 개발
- C 프로그래밍 언어의 특징
    - 유닉스 운영체제와 밀접하게 연결
        - 초기부터 유닉스를 위한 시스템 프로그램 언어로 개발
    - 작고 간단한 언어
        - 단순하기 때문에 배우기 쉽고 다른 컴퓨터에 포팅하기 쉬움
    - 실용적 목적으로 설계
        - 유닉스 운영체제를 만들기 위해 설계
    - 시스템 수준 프로그래밍을 위해 선택된 언어

## 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다
- 시스템에서의 hello.c 실행
    - 각 C 문장들은 다른 프로그램들에 의해 저급 기계어 인스트럭션들로 변역되어야 함
    - 이 인스트럭션들은 실행가능 목적 프로그램(실행가능 목적 파일)이라고 하는 형태로 합쳐져서 바이너리 디스크 파일로 저장됨
- 컴파일러 드라이버
    - 유닉스 시스템에서 다음과 같이 소스파일에서 오브젝트 파일로 번역
        - linux> gcc -o hello hello.c
            - GCC 컴파일러 드라이버
                - 소스파일 hello.c를 읽어서 실행파일인 hello로 번역
- 번역
    - 번역은 다음과 같이 4개의 단계를 거쳐서 실행
        - 전처리 단계
            - 전처리기(cpp)는 본래의 C 프로그램을 #문자로 시작하는 디렉티브(Directive)에 따라 수정
            - .i로 끝나는 새로운 C 프로그램을 생성
        - 컴파일 단계
            - 컴파일러(cc1)는 텍스트파일 hello.i를 텍스트파일인 hello.s로 번역
                - 이 파일에는 어셈블리어 프로그램이 저장
        - 어셈블리 단계
            - 어셈블러(as)가 hello.s를 기계어 인스트럭션으로 번역
                - 이들을 재배치가능 목적프로그램의 형태로 묶어서 hello.o라는 목적파일에 그 결과를 저장
                    - 이 파일은 main 함수의 인스트럭션들을 인코딩하기 위한 17바이트를 포함하는 바이너리 파일
        - 링크 단계
            - C 컴파일러에서 제공하는 표준 C 라이브러리에 들어 있는 printf 함수를 호출하는 것에 주목
                - printf 함수는 이미 컴파일된 별도의 목적파일인 printf.o에 들어 있으며, 이 파일은 hello.o 파일과 어떤 형태로든 결합되어야 함
                    - 링커 프로그램(ld)이 통합작업을 수행
            - hello 파일은 실행가능 목적파일(즉, 실행파일)로 메모리에 적재되어 시스템에 의해 실행
    - 컴파일 시스템
        - 위 네 단계를 실행하는 프로그램들(전처리기, 컴파일러, 어셈블러, 링커)을 합친 것
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F1KTOA%2Fbtrb6Twb4Bu%2FeBo3prFfmzrmN1irQ6BKq0%2Fimg.png">

## 추가정보 2. GNU(GNU's Not Unix) 프로젝트
- GCC
    - GNU 프로젝트에서 개발된 유용한 도구들 중의 하나
- GNU 프로젝트
    - 1984년에 Richard Stallman이 시작한 비과세 자선사업
    - 소스코드가 어떻게 수정되고, 배포될 수 있는가에 관한 제한사항에 상관 없는 완벽하게 유닉스와 유사한 시스템을 개발하겠다는 야심찬 목표를 가지고 시작
    - 유닉스 운영체제에서 커널만을 제외한 나머지 모든 주요 컴포넌트들을 포함하는 환경을 개발
    - 커널은 리눅스 프로젝트에서 별도로 개발
- GNU 환경
    - EMACS 편집기, GCC 컴파일러, GDB 디버거, 어셈블러, 링커, 바이너리 파일 관리를 위한 유틸리티, 그리고 다른 컴포넌트들을 포함
- GCC 컴파일러
    - 다른 많은 언어들도 지원할 정도로 성장
        - C, C++, Fortran, 자바, 파스칼, Object-C, Ada 등을 지원
    - 다른 기계들을 위한 코드를 만들 수 있게 되었음

## 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다
- 프로그램 성능 최적화하기
    - 프로그램머로서 효율적인 코드를 작성하기 위해서 컴파일러의 내부 동작을 알 필요 없음
    - 단, C 프로그램 작성 시 올바른 판단을 하기 위해서는 기계어 수준 코드에 대한 기본적인 이해와 컴파일러가 어떻게 C 문장들을 기계어 코드로 번역하는지 알 필요가 있음
    - 위 내용은 3, 5, 6장에서 배울 예정
- 링크 에러 이해하기
    - 가장 당혹스러운 프로그래밍 에러는 링커의 동작과 관련되어 있으며, 큰 규모의 소프트웨어 시스템을 빌드하려는 경우 발생
        - 링커가 어떤 참조를 풀어낼 수 없다고 할 때는 무엇을 의미하는가?
        - 정적변수와 전역변수의 차이는 무엇인가?
        - 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면 무슨 일이 일어나는가?
        - 정적 라이브러리와 동적 라이브러리의 차이는 무엇인가?
        - 컴파일 명령을 쉘에서 입력할 때 명령어 라인의 라이브러리들의 순서는 무슨 의미가 있는가?
        - 왜 링커와 관련된 에러들은 실행하기 전까지는 나타나지 안는 걸까?
    - 위 질문들에 대한 대답은 7장에서 배울 예정
- 보안 약점(Security Hole) 피하기
    - 오랫동안 버퍼 오버플로우(Buffer Overflow) 취약성이 인터넷과 네트워크상의 보안 약점의 주요 원인
        - 이 취약성은 프로그래머들이 신뢰할 수 없는 곳에서 획득한 데이터의 양과 형태를 주의 깊게 제한해야 할 필요를 거의 익식하지 못하기 때문에 발생
    - 안전한 프로그래밍을 배우는 첫 단계는 프로그램 스택에 데이터와 제어 정보가 저장되는 방식 때문에 생겨나는 영향을 이해하는 것이 필요
    -위 내용은 3장에서 배울 예정

## 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다
- 지금까지 hello.c 소스 프로그램은 컴파일 시스템에 의해 hello라는 실행가능한 목적파일로 번역되어 디스크에 저장됨
    - 이 실행파일을 유닉스 시스템에서 실행하기 위해서 쉘이라는 응용프로그램에 다음과 같이 그 이름을 입력
        ```
        linux> ./hello
        hello, world
        linux>
        ```
    - 쉘
        - 커맨드라인 인터프리터로 프롬프트를 출력하고 명령어 라인을 입력 받아 그 명령을 실행
            - 명령어 라인이 내장 쉘 명령어가 아니면 쉘은 hello 프로그램을 로딩하고 실행한 뒤에 종료를 기다림
            - hello 프로그램은 메시지를 화면에 출력하고 종료
            - 프롬프트를 축력해 주고 다음 입력 명령어 라인을 기다림

### 1.4.1 시스템의 하드웨어 조직
- hello 프로그램을 실행할 때 무슨 일이 일어나는지 설명하기 위해서는 전형적인 시스템에서의 하드웨어 조직을 이해할 필요가 있음
- 버스(Buses)
    - 시스템 내를 관통하는 전기적 배선군
    - 컴포넌트들 간에 바이트 정보들을 전송
    - 위드(Word)라고 하는 고정 크기의 바이트 단위로 데이터를 전송하도록 설계
        - 한 개의 워드를 구성하는 바이트 수는 시스템마다 보유하는 기본 시스템 변수(4바이트 : 32비트 / 8바이트 : 64비트)
- 입출력 장치
    - 시스템과 외부세계와의 연결을 담당
    - 예제에서는 네 개의 입출력 장치를 보유
        - 입력용 키보드와 마우스, 출력용 디스플레이, 데이터와 프로그램의 장기 저장을 위한 디스크 드라이브(hello 프로그램이 저장되어 있음)
    - 각 입출력 장치는 입출력 버스와 컨트롤러나 어댑처를 통해 연결
        - 컨트롤러와 어댑터의 차이 -> 패키징(Packaging)
            - 컨트롤러
                - 디바이스 자체가 칩셋이거나 시스템의 인쇄기판(머더보드)에 장착
            - 어댑터
                - 머더보드의 슬롯에 장착되는 카드
            - 이들 각각의 목적은 입출력 버스와 입출력 장치들 간에 정보를 주고받도록 해주는 일
- 메인 메모리
    - 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치
    - 물리적으로 DRAM(Dynamic Random Access Memory) 칩들로 구성
    - 논리적으로 메모리는 연속적인 바이트들의 배열로, 각각 0부터 시작해서 고유의 주소(배열의 인덱스)를 가짐
- 프로세서
    - 주처리장치(CPU, Central Processing Unit)라고도 부름
    - 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진
    - 프로세서의 중심에는 워드 크기의 저장장치(또는 레지스터)인 프로그램 카운터(PC, Program Counter)가 존재
        - 어느 한순간에 PC는 메인 메모리의 기계어 인스트럭션을 가리킴
        - 시스템에 전원이 공급되는 순간부터 전원이 끊어질 때까지 프로세서는 프로그램 카운터가 가리키는 곳의 인스트럭션을 반복적으로 실행함
        - PC값이 다음 인스트럭션의 위치를 가리키도록 업데이트함
        - 프로세서는 자신의 인스트럭션 집합 구조(Instruction Set Architecture)로 정의되는 매운 단순한 인스트럭션 실행 모델을 따라 작동하는 것처럼 보임
        - 인스트럭션들은 규칙적인 순서로 실행함
        - 프로세서는 PC가 가리키는 메모리로부터 인스트럭션을 읽어오고, 이 인스트럭션에서 비트들을 해석하여 인스트럭션이 지정하는 간단한 동작을 실행하고, PC를 다음 인스트럭션 위치로 업데이트함
            - 이 새로운 위치는 방금 수행한 인스트럭션과 메모리 상에서 연속적일 수도 있고, 그렇지 않을 수도 있음
    - 이와 같은 몇 개의 단순한 동작만이 있을 뿐이며, 이들은 메인 메모리, 레지스터 파일, 수식/논리 처리기(ALU, Arithmetic/Logic Unit) 주위를 순환함
        - 레지스터 파일은 각각 고유의 이름을 갖는 워드 크기의 레지스터 집합으로 구성
        - ALU는 새 데이터와 주소 값을 계산
- 인스트럭션의 요청에 의해 CPU가 실행하는 단순한 작업의 예
    - 적재(Load)
        - 메인 메모리에서 레지스터에 한 바이트 또는 워드를 이전 값을 덮어쓰는 방식으로 복사
    - 저장(Store)
        - 레지스터에서 메인 메모리로 한 바이트 또는 워드를 이전 값을 덮어쓰는 방식으로 복사
    - 작업(Operate)
        - 두 레지스터의 값을 ALU로 복사하고 두 개의 워드로 수식연산을 수행한 뒤, 결과를 덮어쓰기 방식으로 레지스터에 저장
    - 점프(Jump)
        - 인스트럭션 자신으로부터 한 개의 워드를 추출하고, 이것을 PC에 덮어쓰기 방식으로 복사

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcCGHQP%2Fbtrb77adPqE%2FQBTV1iVDCCjq1jcQkKGAs1%2Fimg.png">

### 1.4.2 hello 프로그램의 실행
- 쉘 프로그램은 자신의 인스트럭션을 실행하면서 사용자가 명령을 입력하기를 기다림
- ".\hello'를 입력하면 쉘 프로그램은 각각의 문자를 레지스터에 읽어들인 후 메모리에 저장
- 키보드에서 엔터 키를 누르면 쉘은 명령 입력을 끝마쳤다는 것을 알게 됨
- 이때, 쉘은 파일 내의 코드와 데이터를 복사하는 일력의 인스트럭션을 실행하여 실행파일 hello를 디스크에서 메인 메모리로 로딩
- 데이터 부분은 최종적으로 출력되는 문자 스트링인 "hello, world\n"을 포함함
- 직접 메모리 접근(Direct Memory Access) 기법을 이용하여 데이터는 프로세서를 거치지 않고 디스크에서 메인 메모리로 직접 이동
- hello 목적파일의 코드와 데이터가 메모리에 적재된 후, 프로세서는 hello 프로그램의 main 루틴의 기계어 인스트럭션을 실행하기 시작
- 인스트럭션들은 "hello, world\n" 스트링을 메모리로부터 레지스터 파일로 복사하고, 거기로부터 디스플레이 장치로 전송하여 화면에 글자들을 표시

## 1.5 캐시가 중요하다
- 프로세서-메모리 간 격차에 대응하기 위해 시템 설계자는 보다 작고 빠른 캐시 메모리(간단히 캐시)라 부르는 저장장치를 고안
- 프로세서가 단기간에 필요로 할 가능성이 높은 정보를 임시로 저장할 목적으로 사용
- 프로세서 칩 내에 들어 있는 L1 캐시는 대략 수천 바이트의 데이터를 저장 가능
    - 레지스터 파일만큼 빠른 속도로 액세스 가능
- 이보다 좀 더 큰 L2 캐시는 수백 킬로바이트에서 수 메가 바이트의 용량을 가지며 프로세서와 전용 버스를 통해 연결됨
    - 프로세서가 L2 캐시를 액세스할 때 L1 캐시보다 5배 정도 느리지만, 그래도 여전히 메인 메모리를 액세스할 때보다는 5배에서 크게는 10배까지 더 빠름
- L1, L2 캐시는 SRAM(Static Random Access Memory)라는 하드웨어 기술을 이용해 구현
- 보다 새롭고 보다 강력한 시스템은 심지어 3단계의 캐시를 갖는 경우도 있음
    - L1, L2 그리고 L3 캐시 시스템의 이면에 깔려 있는 아이디어는 프로그램이 지엽적인 영역의 코드와 데이터를 액세스하는 경향인 지역성(Locality)을 활용하여 시스템이 매우 크고 빠른 메모리 효과를 얻을 수 있다는 것
    - 자주 액세스할 가능성이 높은 데이터를 캐시가 보관하도록 설정하면 빠른 캐시를 이용해서 대부분의 메모리 작업을 수행할 수 있게 됨
- 이 책의 가장 중요한 교훈 중의 하나는 캐시 메모리를 이해하는 응용 프로그래머는 캐시를 활용하여 자신의 프로그램 성능을 10배 이상 개선할 수 있다는 것

## 1.6 저장장치들은 계층구조를 이룬다
- 모든 컴퓨터 시스템의 저장장치들은 메모리 계층구조로 구성됨
- 계층의 꼭대기에서부터 맨 밑바닥까지 이동할수록 저장장치들은 더 느리고, 더 크고, 바이트당 가격이 쌈
- 레지스터 파일은 계층구조의 최상위인 레벨 0, 즉 L0을 차지
- 메모리 계층구조의 주요 아이디어는 한 레벨의 저장장치가 다음 하위레벨 저장장치의캐시 역할을 한다는 것
    - L1과 L2의 캐시는 각각 L2와 L3의 캐시
    - L3 캐시는 메인 메모리의 캐시이고, 이 캐시는 디스크의 캐시 역할을 함

## 1.7 운영체제는 하드웨어를 관리한다
- 운영체제는 하드웨어와 소프트웨어 사이에 위한 소프트웨어 계층으로 생각할 수 있음
- 응용프로그램이 하드웨어를 제어하려면 언제나 운영체제를 통해서 해야 함
- 운영체제의 두 가지 주요 목적
    - 제멋대로 동작하는 응용프로그램들이 하드웨어를 잘못 사용하는 것을 막기 위함
    - 응용프로그램들이 단순하고 균일한 매커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기 위함

## 추가정보 3. 유닉스, 프식스(Posic), 표준 유닉스 규격
- 1960년대는 IBM의 OS/360, 하니웰의 Multics와 같이 거대하고 복잡한 운영체제의 시대
- OS/360이 역사상 가장 성공적인 소프트웨어 프로젝트였다면 Multics는 몇 년간이나 유지되었지만 광범위하게 사용되지 못함
    - 벨 연구소는 이 Multics 프로젝트의 초기 파트너였지만 프로젝트의 복잡성과 더딘 진척으로 손을 땜
- 벨 연구소 연구원들은 1969년에 Digital Equipment Corporation PDP-7 컴퓨터를 위한 보다 단순한 운영체제를 개발하기 시작
    - 전적으로 기계어로 개발
    - 새로운 시스템에 적용된 계층적 파일시스템, 쉘 사용자수준 프로세스 같은 개념들은 Multics에서 가져왔지만 보다 작고 간단한 패키지 형태로 구현
    - 이 커널은 1973년 C 언어로 재작성되었으며, 유닉스는 1974년 공개됨
    - 소스코를 학교에 공개하였으며, 대학에서 큰 인기를 얻음
    - 중요한 결과로 캘리포니아 주 버클리대학의 연구원들은 1970년대 말과 1980년대 초, 가상메모리와 인터넷 프로토콜을 추가해서 Unix 4.xBSD(Berkeley Software Distribution)라는 일련의 버전을 공개
    - 동시에 벨 연구소는 System V 유닉스라는 자체 버전을 공개
    - Sun 마이크로시스템사의 Solaris 같은 다른 회사으 ㅣ버전들은 BSD와 System V를 기반으로 개발된 것
- 여기서 유식스 업체들이 호환성이 없는 지신들만의 새로운 기능을 추가하면서 문제가 발생
    - 이러한 추세를 막기 위해 IEEE(Institute for Electrical and Electronics Engineers)는 후에 Richard Stallman에 의해 포식스(Posic)라고 명명된 유닉스의 표준화 노력을 후훤함
    - 그 결과, 포식스 표준이라고 알려진 일련의 표준이 정의됨
    - 이 표준은 유닉스 시스템 콜, 쉘 프로그램, 유틸리티를 위한 C언어 인터페이스, 쓰레드, 네트워크 프로그래밍 등의 주제들을 다루고 있음
    - 최근에는 별도의 표준화 노력으로 "표준유닉스 규격 Standard Unix Specification"이 단일 통일 유닉스시스템 표준을 위한 활동으로 포식스 외에 추가됨
    - 표준화 활동의 결과로 더 많은 시스템이 보다 완전하게 포식스 표준을 준수하게 됨에 따라 유닉스 버전들 간의 차이점들은 거의 대부분 사라짐

### 1.7.1 프로세스
- 프로세스란 실행 중인 프로그램에 대한 운영체제의 추상화
- 다수의 프로세스들은 동일한 시스템에서 동시에 실행될 수 있으며, 각 프로세스는 하드웨어를 배타적으로 사용하는 것처럼 느낌
    - 동시에(Concurrently) : 한 프로세스의 인스트럭션들이 다른 프로세스의 인스트럭션들과 섞인다는 것
- 대부분의 시스템에서 프로세스를 실행할 CPU의 숫자보다 더 많은 프로세스들이 존재
- 이전의 시스템들은 한 번에 한 개의 프로그램만 실행할 수 있었지만, 요즘의 멀티코어 프로세서들은 여러 개의 프로그램을 동시에 실행 가능