# CHAPTER09 : 가상메모리(Virtual Memory)

## 9.9 동적 메모리 할당
- 가상메모리의 영역을 저수준의 mmap과 munmap 함수를 사용해서 생성하고 삭제할 수 있다.
- 하지만, 대개 추가적인 가상메모리를 런타임에 획득할 필요가 있을 때, 동적 메모리 할당기를 사용하는 것을 더 선호한다.
- 동적 메모리 할당기
    - 힙(heap)이라고 하는 프로세스의 가상메모리 영역을 관리한다.
    - 데이터와 힙의 경계는 Top of the heap이 있고, 이를 가리키는 포인터 변수 brk(break)가 있다.
    - 힙을 다양한 크기의 블록들의 집합으로 관리한다.
        - 블록 : 할당되었거나 가용한 가상메모리의 연속적인 묶음
    - 할당된 블록은 응용하기 위해 명시적으로 보존된다.
    - 가용한(free) 블록은 할당을 위해 사용할 수 있고, 응용이 명시적으로 할당할 때까지 가용한 상태로 남아있다.
    - 할당된 블록은 응용에 의해 명시적으로 또는 메모리 할당기에 의해 묵시적으로 반환될 때까지 할당된 채로 남아있다.  
    <img src="https://velog.velcdn.com/images/supssson/post/00548582-4f9a-4b51-8549-ed538cff5d70/image.jpeg" height="300" width="500"></img>
    - 할당기 유형
        - 두 개의 유형이 있으며 모두 응용이 명시적으로 블록을 할당하도록 요구하지만, 반환할 때의 차이점이 있다.
        - 명시적인 할당기(Explicit allocators)
            - 명시적으로 할당된 블록을 반환해 줄 것을 요구한다.
            - C언어에서는 malloc 함수로 블록 할당하고, free 함수로 블록을 반환한다.
            - C++에서는 new와 delete로 블록을 할당하고 반환한다.
        - 묵시적 할당기(Implicit allocators)
            - 자동으로 사용자가 함수로서 명시적 반환을 요구하지 않아도 알아서 사용하지 않는 메모리를 반환하도록 하는 것이다.
            - 가비지 컬렉터(garbage collector)라고도 부른다.
                - 가비지 컬렉터 : 자동으로 사용하지 않은 할당된 블록을 반환시켜주는 작업
                - List, ML, 자바 같은 상위수준 언어들은 할당된 블록들을 반환시키기 위해 가비지 컬렉션을 사용한다.

## 9.9.1 malloc과 free 함수
- malloc 함수
    ```C
    #include <stdlib.h>
    void *malloc(size_t, size);
    // Returns : pointer to allocated block if OK, NULL on error
    ```
    - C 표준 라이브러리는 malloc 패키지로 알려진 명시적인 할당기를 제공한다.
    - 프로그램은 malloc 함수를 호출해서 힙으로부터 블록들을 할당받는다.
    - 블록 내에 포함될 수 있는 어떤 종류의 데이터 객체에 대해서 적절히 정렬된 최소 size 바이트를 갖는 메모리 블록의 포인터를 반환한다.
        - 할당받는 메모리의 크기는 32비트에서는 주소가 8의 배수이며, 64비트에서는 16배수이다.
            - 최소 단위의 메모리 크기가 32비트에서는 8바이트, 64비트에서는 16바이트라는 것을 의미한다.
    - 할당받은 메모리를 초기화하고 싶다면 calloc 함수를 사용한다. -> 할당된 메모리를 0으로 초기화 해준다.
    - 이전에 할당받은 메모리의 크기를 변경하고 싶다면 realloc 함수를 사용한다.
    - mmap과 munmap 함수를 사용해서 명시적으로 힙 메모리를 할당하거나 반환하며, sbrk 함수를 사용한다.
- brk 함수
    ```C
    #include <unistd.h>
    int *brk(void *addr)
    ```
    - addr 주소 위치에 program break(현재 프로세스의 data segment의 끝부분 바로 다음 자리)를 설정한다.
    - program break의 위치를 옮김으로써 메모리를 할당하거나 반환하고, 성공 시 brk는 0을, 실패 시 -1을 반환한다.
- sbrk 함수
    ```C
    #include <unistd.h>
    void *sbrk(intptr_t incr);
    // Returns : old brk pointer on success, -1 on error
    ```
    - 커널의 brk 포인터에 incr(increment)을 더해서 힙을 늘리거나 줄인다.
    - 성공 시 이전의 brk 값을 반환하고, 실패 시 -1을 반환한다.
    - incr이 0이면, sbrk는 현재의 brk 값을 반환한다.
    - sbrk를 음수 incr로 호출하면 합법적이기는 하지만, 리턴 값(이전의brk 값)이 새로운 힙의 탑을 지나서 abs(incr) 바이트를 가리키기 때문에 복잡해진다.
- free 함수
    ```C
    #include <stdlib.h>
    void free(void *ptr);
    // Returns : nothing
    ```
    - 더 이상 할당받은 메모리가 필요하지 않다면 free 함수로 반환한다.
    - ptr 인자는 malloc, calloc, realloc에서 획득한 할당된 블록의 시작을 기리켜야 한다.
        - free 함수는 리턴값이 없기 때문에 제대로 동작 했다는 것을 알기 어렵고, 런타임 에러를 유발할 가능성이 있기 때문이다.
    - (d)는 p2에 할당된 6워드 블록을 반환해준 상태이다.
        - free 함수를 호출하여 블록을 반환하더라도 포인터 p2는 여전히 malloc된 블록을 가리킨다.
        - p2가 새로운 malloc 콜에 의해 다시 초기화될 때까지 p2를 사용하지 않는다.  
        <img src="https://velog.velcdn.com/images/supssson/post/b54954a3-cf0c-42c1-9143-c29fa8836608/image.jpeg" height="150" width="500"></img>

## 9.9.2 왜 동적 메모리 할당인가?
- 동적 메모리 할당을 사용하는 이유는 프로그램을 실제 실행시키기 전에는 자료 구조의 크기를 알 수 잆는 경우들이 존재하기 때문이다.
    - 예를 들어, n개의 정수 리스트를 라인마다 한 개씩 배열로 읽는 프로그램을 작성 한다고 하자.
        - 입력은 정수 n과 읽고 배열에 저장해야 하는 n개의 정수로 구성되어 있다.
        - 가장 간단한 방법은 배열을 정해진 최대 배열 크기를 갖는 정적 배열로 정의하는 것이다.
        ```C
        #include <csapp.h>
        #define MAXN 15213

        int array[MAXN];

        int main()
        {
            int i, n;

            scanf("%d", &n);
            if(n > MAXN)
                app_error("Input file too big");
            for(i = 0; i < n; i++)
                scanf("%d", &array[i]);
            exit(0);
        }
        ```
        - 위 코드처럼 배열을 정해진 크기를 사용해서 할당하는 것은 종종 나쁜 방법이 된다.
            - MAXN보다 더 큰 파일을 읽으려고 한다면, 프로그램을 더 큰 MAXN 값을 사용해서 컴파일하는 것이 유일한 대책이다.
        - 더 나은 방법은 n 값을 알 수 있을 때 배열을 런타임에 동적으로 할당하는 것이다.
            - 배열의 최대 크기는 가용한 가상메모리의 양에 의해서만 제한된다.
            ```C
            #include <csapp.h>
        
            int main()
            {
                int *array, i, n;

                scanf("%d", &n);
                array = (int *)malloc(n * sizeof(int));
                for(i = 0; i < n; i++)
                    scanf("%d", &array[i]);
                free(array);
                exit(0);
            }
            ```

## 9.9.3 할당기 요구사항과 목표
- 명시적 할당기들은 다소 엄격한 제한사항 내에서 동작한다.
- 요구사항
    - 임의의 요청 순서 처리하기
        - 할당기는 할당/반환 요청이 들어왔을 때, 즉시 그 요청을 시행해야 한다.
    - 요청에 즉시 응답하기
        - 할당기는 블록들을 이들이 어떤 종류의 데이터 객체라도 저장할 수 있도록 하는 방식으로 정렬해야 한다.
    - 힙만 사용하기
        - 확장성을 갖기 위해서 할당기가 사용하는 비확장성 자료 구조들은 힙 자체에 저장되어야 한다.
    - 블록 정렬하기(정렬 조건)
        - 할당기는 블록들을 이들이 어떤 종류의 데이터 객체라도 저장할 수 있도록 하는 하는 방식으로 정렬해야 한다.
    - 할당된 블록을 수정하지 않기
        - 할당기는 가용 블록을 조작하거나 변경할 수만 있다.
        - 블록이 할당되면 이들을 수정하거나 이동하지 않는다.
        - 따라서, 할당된 블록들을 압축하는 것 같은 기법들은 허용되지 않는다.
- 목표
    - 처리량 극대화하기
        - n번의 할당과 반환 요청의 배열이 주어졌을 때, 할당기의 처리량을 최대화하려고 하며, 이것은 단위 시간당 완료되는 요청의 수로 정의한다.
        - 일반적으로, 할당과 반환 요청들을 만족시키기 위한 평균 시간을 최소화해서 처리량을 최대화한다.
    - 메모리 이용도를 최대화하기
        - 한 시스템에서 모든 프로세스에 의해 할당된 가상메모리의 양은 디스크 내의 스왑 공간의 양에 의해 제한된다.
        - 최고 이용도(peak utilization)
            - 할당기가 얼마나 힙을 효울적으로 사용하는지를 규정하는 방법 중에서 가장 유용한 단위이다.  
            <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRvzhk%2FbtqTF2K38h0%2FUOGkXByKJ2eOwd0dexNn60%2Fimg.png"></img>
            - 간단하게 말하면, 이용도U = ( 실제로 사용하는 힙의 크기 = maxPi ) / ( 할당된 힙의 크기 = Hk )
            - 즉, U = 1이면 낭비되는 것 없이 힙을 온전히 그대로 사용하고 있고, U = 0 이라면 실제로 사용되는 힙이 없음에도 불구하고 힙이 할당되어 있는 것이다.

## 9.9.4 단편화(Fragmentation)
- 단편화
    - 메모리 공간이 작은 조각으로 나눠져 사용 가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태일 떄 발생한다.
- 단편화 종류
    - 내부 단편화
        - 할당된 블록이 요구하는 데이터보다 더 크게 할당되어 사용하는 메모리 공간을 낭비할 때 발생한다.
        - 예를 들어, 아래 그림을 보자.  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbfy5Je%2FbtqTIpMKXVU%2FNGzbVdi7cNZbyfjxxdrHW0%2Fimg.png"></img>
            - 정수는 4바이트이므로 5 * sizeof(int)는 5칸을 차지한다.
            - 하지만, 64바이트에서는 8바이트씩(2칸씩)만 배치할 수 있으므로 2의 배수로 할당해서 6칸을 차지한다.
            - 따라서, 4바이트가 낭비되고 있는 상태이다.
        - 정량화하기가 간단
            - 단순히 할당된 블록의 크기와 이들의 데이터 사이의 차이의 합이다.
    - 외부 단편화
        - 총 메모리 공간은 충분하지만, 요청을 처리할 수 있는 단일한 가용 블록이 없을 때 발생한다.
        - 예를 들어, 아래 그림을 보자.  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSQYyv%2FbtqTF3QMGDL%2FcMgVLmauXSFSISfdR3UZek%2Fimg.png"></img>
            - 현재 여유 메모리는 6칸(24바이트)이나, 4칸과 2칸으로 나누어져 있으므로 24바이트 블록을 할당할 수 없다.
        - 할당기의 요구사항 중 "할당된 블록을 수정하지 않기"로 인해 할당된 블록을 수정하거나 이동이 불가능하여 정렬할 수 없으므로 대응이 어렵다.
        - 내부 단편화보다 측정하기 더 어렵고 예측하기 불가능하기 때문에 할당기들은 대개 많은 수의 더 작은 가용 블록들보다는 더 적은 수의 큰 블록들을 유지하려는 방법을 채택한다.
            - 예를 들어, 8칸을 배정할 경우 4개로 쪼개서 2칸씩 여기저기에 배치하는 것 보다는 8칸짜리로 한 곳에 배치하는 것을 선호한다는 것이다.

## 9.9.5 구현 이슈
- 예를 들어, 아래 그림을 보자.  
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzkXmy%2FbtqTDbPAksa%2FlqNCnFS46kDcNSCl2OTYA1%2Fimg.png"></img>
    - p1, p2, p3는 각각 할당된 공간을 가리키는 포인터이며, p1, p2, p3는 할당된 공간의 처음을 가리키고, p4는 p3가 사용하는 오른쪽 공간에 온다고 생각해보자.
        - 여기서 free(p2)를 했는데, 사실 free 함수는 아무것도 하지 않는다고 가정했을 경우 2칸을 배정받아도 p2의 공간이 아닌 p3 다음에 올 것이다.
        - 이 경우에는 연산이 매우 간단하므로(심지어 free는 아무것도 하지 않음), 속도는 매우 빠를 것이나 금방 메모리가 가득찰 것이다.
    - 반대로, free가 해당 공간을 비우고 다음 배정을 할 경우, 메모리의 상황에서 모든 경우의 수를 고려해서 새로운 공간을 배정한다고 하자.
        - 그 경우에는 메모리의 공간은 극도로 효율적일 것(최고이용도라고 쓰기도 함)이나, 속도는 매우 느릴 것이다.
    - 따라서, 할당기는 속도와 공간의 효율사이에서 좋은 균형을 추구해야하며, 다음과 같은 이슈를 고려해야 한다.
- 고려해야할 이슈
    - 가용블록 구성 : 어떻게 메모리의 비어있는 공간이 어디에, 얼마만큼 있는지 알 것인가?
    - 배치 : 어떻게 블록을 배치해야 효율적으로 공간을 사용할 수 있을 것인가?
    - 분할 : 새로운 블록을 배치한 후, 남은 부분들로 무엇을 할 것인가?
    - 연결 : 방금 반환된 블록으로 무엇을 할 것인가?

## 9.9.6 묵시적 가용 리스트(Implicit Free Lists)
- 실전에서 쓰이는 할당기는 블록 경계를 구분하고, 할당된 블록과 가용 블록을 구분하기 위해 데이터 구조를 필요로 한다.
- 대부분의 할당기는 이 정보를 블록 내에 저장하며, 단순한 접근법은 아래와 같다.  
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Feibcwo%2FbtqTAEdnzDC%2FeKvz2Xx1TBOc5VODBhhiT1%2Fimg.png"></img>
    - 한 블록은 1워드 헤더, 데이터와 패딩으로 구성된다.
    - 헤더
        - 블록 크기(헤더와 추가적인 패당 포함)와 블록이 할당되었는지 가용 상태인지를 인코딩한다.

## 참조
- https://firecatlibrary.tistory.com/34