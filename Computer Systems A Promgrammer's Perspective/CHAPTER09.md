# CHAPTER09 : 가상메모리(Virtual Memory)

## 9.9 동적 메모리 할당
- 가상메모리의 영역을 저수준의 mmap과 munmap 함수를 사용해서 생성하고 삭제할 수 있음
- 하지만, 대개 추가적인 가상메모리를 런타임에 획득할 필요가 있을 때, 동적 메모리 할당기를 사용하는 것이 더 선호
- 동적 메모리 할당기
    - 힙(heap)이라고 하는 프로세스의 가상메모리 영역을 관리
    - 데이터와 힙의 경계는 Top of the heap이 있고, 이를 가리키는 포인터 변수 brk(break)가 있음
    - 힙을 다양한 크기의 블록들의 집합으로 관리
        - 블록 : 할당되었거나 가용한 가상메모리의 연속적인 묶음
    - 할당된 블록은 응용하기 위해 명시적으로 보존됨
    - 가용한(free) 블록은 할당을 위해 사용할 수 있고, 응용이 명시적으로 할당할 때까지 가용한 상태로 남음
    - 할당된 블록은 응용에 의해 명시적으로 또는 메모리 할당기에 의해 묵시적으로 반환될 때까지 할당된 채로 남음  
<img src="https://velog.velcdn.com/images/supssson/post/00548582-4f9a-4b51-8549-ed538cff5d70/image.jpeg" height="300" width="500">
    - 할당기 유형
        - 두 개의 유형이 있으며 모두 응용이 명시적으로 블록을 할당하도록 요구하지만, 반환할 때의 차이점이 있음
        - 명시적인 할당기(Explicit allocators)
            - 명시적으로 할당된 블록을 반환해 줄 것을 요구
            - C언어에서는 malloc 함수로 블록 할당하고, free 함수로 블록 반환
            - C++에서는 new와 delete로 블록을 할당하고 반환
        - 묵시적 할당기(Implicit allocators)
            - 자동으로 사용자가 함수로서 명시적 반환을 요구하지 않아도 알아서 사용하지 않는 메모리를 반환하도록 하는 것
            - 가비지 컬렉터(garbage collector)라고도 부름
                - 가비지 컬렉터 : 자동으로 사용하지 않은 할당된 블록을 반환시켜주는 작업
                - List, ML, 자바 같은 상위수준 언어들은 할당된 블록들을 반환시키기 위해 가비지 컬렉션을 사용

## 9.9.1 malloc과 free 함수
- malloc 함수
    ```C
    #include <stdlib.h>
    void *malloc(size_t, size);
    // Returns : pointer to allocated block if OK, NULL on error
    ```
    - C 표준 라이브러리는 malloc 패키지로 알려진 명시적인 할당기를 제공
    - 프로그램은 malloc 함수를 호출해서 힙으로부터 블록들을 할당받음
    - 블록 내에 포함될 수 있는 어떤 종류의 데이터 객체에 대해서 적절히 정렬된 최소 size 바이트를 갖는 메모리 블록의 포인터를 반환
        - 할당받는 메모리의 크기는 32비트에서는 주소가 8의 배수이며, 64비트에서는 16배수
            - 최소 단위의 메모리 크기가 32비트에서는 8바이트, 64비트에서는 16바이트라는 것을 의미
    - 할당받은 메모리를 초기화하고 싶다면 calloc 함수를 사용(할당된 메모리를 0으로 초기화 해줌)
    - 이전에 할당받은 메모리의 크기를 변경하고 싶다면 realloc 함수를 사용
    - mmap과 munmap 함수를 사용해서 명시적으로 힙 메모리를 할당하거나 반환하며, sbrk 함수를 사용
- brk 함수
    ```C
    #include <unistd.h>
    int *brk(void *addr)
    ```
    - addr 주소 위치에 program break(현재 프로세스의 data segment의 끝부분 바로 다음 자리)를 설정
    - program break의 위치를 옮김으로써 메모리를 할당하거나 반환, 성공시 brk는 0을 반환하고 실패시 -1을 반환
- sbrk 함수
    ```C
    #include <unistd.h>
    void *sbrk(intptr_t incr);
    // Returns : old brk pointer on success, -1 on error
    ```
    - 커널의 brk 포인터에 incr(increment)을 더해서 힙을 늘리거나 줄임
    - 성공 시 이전의 brk 값을 반환하고, 실패 시 -1을 반환
    - incr이 0이면, sbrk는 현재의 brk 값 반환
    - sbrk를 음수 incr로 호출하면 합법적이기는 하지만, 리턴 값(이전의brk 값)이 새로운 힙의 탑을 지나서 abs(incr) 바이트를 가리키기 때문에 복잡해짐
- free 함수
    ```C
    #include <stdlib.h>
    void free(void *ptr);
    // Returns : nothing
    ```
    - 더 이상 할당받은 메모리가 필요하지 않다면 free 함수로 반환
    - ptr 인자는 malloc, calloc, realloc에서 획득한 할당된 블록의 시작을 기리켜야 함
        - free 함수는 리턴값이 없기 때문에 제대로 동작 했다는 것을 알기 어렵고, 런타임 에러를 유발할 가능성이 있음
    - (d)는 p2에 할당된 6워드 블록을 반환해준 상태
        - free 함수를 호출하여 블록을 반환하더라도 포인터 p2는 여전히 malloc된 블록을 가리킴
        - p2가 새로운 malloc 콜에 의해 다시 초기화될 때까지 p2를 사용하지 않음  
<img src="https://velog.velcdn.com/images/supssson/post/b54954a3-cf0c-42c1-9143-c29fa8836608/image.jpeg" height="150" width="500">

## 9.9.2 왜 동적 메모리 할당인가?
- 동적 메모리 할당을 사용하는 이유는 프로그램을 실제 실행시키기 전에는 자료 구조의 크기를 알 수 잆는 경우들이 존재하기 때문임
    - 예를 들어, n개의 정수 리스트를 라인마다 한 개씩 배열로 읽는 프로그램을 작성 한다고 하자
        - 입력은 정수 n과 읽고 배열에 저장해야 하는 n개의 정수로 구성
        - 가장 간단한 방법은 배열을 정해진 최대 배열 크기를 갖는 정적 배열로 정의하는 것
        ```C
        #include <csapp.h>
        #define MAXN 15213

        int array[MAXN];

        int main()
        {
            int i, n;

            scanf("%d", &n);
            if(n > MAXN)
                app_error("Input file too big");
            for(i = 0; i < n; i++)
                scanf("%d", &array[i]);
            exit(0);
        }
        ```
        - 위 코드처럼 배열을 정해진 크기를 사용해서 할당하는 것은 종종 나쁜 방법이 됨
            - MAXN보다 더 큰 파일을 읽으려고 한다면, 프로그램을 더 큰 MAXN 값을 사용해서 컴파일하는 것이 유일한 대책
        - 더 나은 방법은 n 값을 알 수 있을 때 배열을 런타임에 동적으로 할당하는 것
            - 배열의 최대 크기는 가용한 가상메모리의 양에 의해서만 제한
            ```C
            #include <csapp.h>
        
            int main()
            {
                int *array, i, n;

                scanf("%d", &n);
                array = (int *)malloc(n * sizeof(int));
                for(i = 0; i < n; i++)
                    scanf("%d", &array[i]);
                free(array);
                exit(0);
            }
            ```

## 9.9.3 할당기 요구사항과 목표
- 명시적 할당기들은 다소 엄격한 제한사항 내에서 동작
- 요구사항
    - 임의의 요청 순서 처리하기
        - 할당기는 할당/반환 요청이 들어왔을 때, 즉시 그 요청을 시행해야 함
    - 요청에 즉시 응답하기
        - 할당기는 블록들을 이들이 어떤 종류의 데이터 객체라도 저장할 수 있도록 하는 방식으로 정렬해야 함
    - 힙만 사용하기
        - 확장성을 갖기 위해서 할당기가 사용하는 비확장성 자료 구조들은 힙 자체에 저장되어야 함
    - 블록 정렬하기(정렬 조건)
        - 할당기는 블록들을 이들이 어떤 종류의 데이터 객체라도 저장할 수 있도록 하는 하는 방식으로 정렬해야 함
    - 할당된 블록을 수정하지 않기
        - 할당기는 가용 블록을 조작하거나 변경할 수만 있음
        - 블록이 할당되면 이들을 수정하거나 이동하지 않음
        - 따라서, 할당된 블록들을 압축하는 것 같은 기법들은 허용되지 않음
- 목표
    - 처리량 극대화하기
        - n번의 할당과 반환 요청의 배열이 주어졌을 때, 할당기의 처리량을 최대화하려고 하며, 이것은 단위 시간당 완료되는 요청의 수로 정의
        - 일반적으로, 할당과 반환 요청들을 만족시키기 위한 평균 시간을 최소화해서 처리량을 최대화 함
    - 메모리 이용도를 최대화하기
        - 한 시스템에서 모든 프로세스에 의해 할당된 가상메모리의 양은 디스크 내의 스왑 공간의 양에 의해 제한
        - 최고 이용도(peak utilization)
            - 할당기가 얼마나 힙을 효울적으로 사용하는지를 규정하는 방법 중에서 가장 유용한 단위  
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRvzhk%2FbtqTF2K38h0%2FUOGkXByKJ2eOwd0dexNn60%2Fimg.png">
            - 간단하게 말하면, 이용도U = ( 실제로 사용하는 힙의 크기 = maxPi ) / ( 할당된 힙의 크기 = Hk )
            - 즉, U = 1이면 낭비되는 것 없이 힙을 온전히 그대로 사용하고 있고, U = 0 이라면 실제로 사용되는 힙이 없음에도 불구하고 힙이 할당되어 있는 것

## 9.9.4 단편화(Fragmentation)
- 단편화
    - 메모리 공간이 작은 조각으로 나눠져 사용 가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태일 떄 발생
- 단편화 종류
    - 내부 단편화
        - 할당된 블록이 요구하는 데이터보다 더 크게 할당되어 사용하는 메모리 공간을 낭비할 때 발생
        - 예를 들어, 아래 그림을 보자  
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbfy5Je%2FbtqTIpMKXVU%2FNGzbVdi7cNZbyfjxxdrHW0%2Fimg.png">
            - 정수는 4바이트이므로 5 * sizeof(int)는 5칸을 차지 함
            - 하지만, 64바이트에서는 8바이트씩(2칸씩)만 배치할 수 있으므로 2의 배수로 할당해서 6칸을 차지 함
            - 따라서, 4바이트가 낭비되고 있는 상태
        - 정량화하기가 간단
            - 단순히 할당된 블록의 크기와 이들의 데이터 사이의 차이의 합
    - 외부 단편화
        - 총 메모리 공간은 충분하지만, 요청을 처리할 수 있는 단일한 가용 블록이 없을 때 발생
        - 예를 들어, 아래 그림을 보자  
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSQYyv%2FbtqTF3QMGDL%2FcMgVLmauXSFSISfdR3UZek%2Fimg.png">
            - 현재 여유 메모리는 6칸(24바이트)이나, 4칸과 2칸으로 나누어져 있으므로 24바이트 블록을 할당할 수 없음
        - 할당기의 요구사항 중 "할당된 블록을 수정하지 않기"로 인해 할당된 블록을 수정하거나 이동이 불가능하여 정렬할 수 없으므로 대응이 어려움
        - 내부 단편화보다 측정하기 더 어렵고 예측하기 불가능하기 때문에 할당기들은 대개 많은 수의 더 작은 가용 블록들보다는 더 적은 수의 큰 블록들을 유지하려는 방법을 채택
            - 예를 들어, 8칸을 배정할 경우 4개로 쪼개서 2칸씩 여기저기에 배치하는 것 보다는 8칸짜리로 한 곳에 배치하는 것을 선호한다는 것