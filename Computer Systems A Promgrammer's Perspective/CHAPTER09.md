# CHAPTER09 : 가상메모리(Virtual Memory)

## 9.9 동적 메모리 할당
- 가상메모리의 영역을 저수준의 mmap과 munmap 함수를 사용해서 생성하고 삭제할 수 있지만, C프로그래머들은 대개 추가적인 가상메모리를 런타임에 획득할 필요가 있을 때, 동적 메모리 할당기를 사용하는 것을 좀 더 편리하고 호환성이 좋다고 생각
- 동적 메모리 할당기
    - 힙(heap)이라고 하는 프로세스의 가상메모리 영역을 관리
    - 일반화의 오류를 범하지 않는 한도에서 힙이 미초기화된 데이터 영역 직후에 시작해서 위쪽으로(높은 주소 방향으로) 커지는 무요구 메모리 영역이라고 가정
    - 커널은 힙의 꼭대기를 가리키는 변수 brk(break)를 사용
        <img src="https://velog.velcdn.com/images/supssson/post/00548582-4f9a-4b51-8549-ed538cff5d70/image.jpeg" height="300" width="400">
    - 힙을 다양한 크기의 블록들의 집합으로 관리
        - 블록은 할당되었거나 가용한 가상메모리의 연속적인 묶음
    - 할당된 블록은 응용하기 위해 명시적으로 보존
    - 가용한(free) 블록은 할당을 위해 사용할 수 있고, 응용이 명시적으로 할당할 때까지 가용한 상태로 남음
    - 할당된 블록은 응용에 의해 명시적으로 또는 메모리 할당기 자신에 의해 묵시적으로 반환될 때까지 할당된 채로 남음
    - 두 개의 기본 유형이 존재
        - 두 유형 모두 응용이 명시적으로 블록을 할당하도록 요구
        - 어떤 엔트리가 할당된 블록을 반환하기 위해서 무엇이 사용되어야 하는지에 대해서 차이가 남
        - 명시적인 할당기(Explicit allocators)
            - 응용이 명시적으로 할당된 블록을 반환해 줄 것을 요구
            - 예를 들어, C 표준 라이브러리는 malloc 패키지라고 하는 명시적 할당기를 제공
                - malloc 함수를 호출해서 블록 할당
                - free 함수를 호출해서 블록 반환
            - C++ 에서는 new와 delete를 호출하여 블록 할당 및 반환
        - 묵시적 할당기(Implicit allocators)
            - 언제 할당된 블록이 더 이상 프로그램에 의해 사용되지 않고 블록을 반환하는지를 할당기가 검출할 수 있을 것을 요구
            - 묵시적 할당기는 가비지 컬렉터(garbage collector)라고 알려지 있음
                - 가비지 컬렉션 : 자동으로 사용하지 않은 할당된 블록을 반환시켜주는 작업
                - List, ML, 자바 같은 상위수준 언어들은 할당된 블록들을 반환시키기 위해 가비지 컬렉션을 사용

## 추가정보. 워드는 얼마나 큰가?
- 3장에서 인텔이 4바이트 객체를 더블 워드라고 했지만, 이번 장에서는 워드는 4바이 객체이고, 더블 워드는 8바이트 객체라고 가정

## 9.9.1 malloc과 free 함수
- malloc 함수
    ```C
    #include <stdlib.h>
    void *malloc(size_t, size);
    // Returns : pointer to allocated block if OK, NULL on error
    ```
    - C 표준 라이브러리는 malloc 패키지로 알려진 명시적인 할당기를 제공
    - 프로그램은 malloc 함수를 호출해서 힙으로부터 블록들을 할당받음
    - 블록 내에 포함될 수 있는 어떤 종류의 데이터 객체에 대해서 적절히 정렬된 최소 size 바이트를 갖는 메모리 블록의 포인터를 반환
        - 실제 구현에서 정렬은 코드가 32비트 모드(gcc -m32) 또는 64비트 모드(기본설정)에서 동작하도록 컴파일되었는지 여부에 따라 다름
        - 32비트 모드에서의 malloc : 주소가 항상 8의 배수인 블록을 반환
        - 64비트 모드에서의 malloc : 주소가 항상 16의 배수인 블록을 반환
    - 프로그램이 가용한 가상메모리보다 더 큰 크기의 메모리 블록을 요청한 경우
        - 널을 리턴하고 errno를 설정
    - 리턴하는 메모리를 초기화하지 않음
        - 초기화한 동적 메모리를 원하는 응용들은 calloc 함수를 사용
        - calloc 함수는 할당된 메모리를 0으로 초기화하는 calloc 함수 주위의 얇은 래퍼 함수
        - 이전에 할당된 블록의 크기를 변경하려는 응용은 realloc 함수를 사용
    - mmap과 munmap 함수를 사용해서 명시적으로 힙 메모리를 할당하거나 반환하며, sbrk 함수를 사용
- brk 함수
    ```C
    #include <unistd.h>
    int *brk(void *addr)
    ```
    - addr 주소 위치에 program break(현재 프로세스의 data segment의 끝부분 바로 다음 자리)를 설정
    - program break의 위치를 옮김으로써 메모리를 할당하거나 반환, 성공시 brk는 0을 반환하고 실패시 -1을 반환
- sbrk 함수
    ```C
    #include <unistd.h>
    void *sbrk(intptr_t incr);
    // Returns : old brk pointer on success, -1 on error
    ```
    - 커널의 brk 포인터에 incr(increment)을 더해서 힙을 늘리거나 줄임
        - 성공 : 이전의 brk 값 반환
        - 실패 : -1을 반환하고 errno를 ENOMEM으로 설정
    - inc이 0이면, sbrk는 현재의 brk 값 반환
    - sbrk를 음수 incr로 호출하면 합법적이기는 하지만, 리턴 값(이전의brk 값)이 새로운 힙의 탑을 지나서 abs(incr) 바이트를 가리키기 때문에 복잡해짐
- free 함수
    ```C
    #include <stdlib.h>
    void free(void *ptr);
    // Returns : nothing
    ```
    - 프로그램들은 할당된 힙 블록을 free 함수를 호출하여 반환
    - ptr 인자는 malloc, calloc, realloc에서 획득한 할당된 블록의 시작을 기리켜야 함
        - free 함수는 리턴값이 없기 때문에 제대로 동작 했다는 것을 알기 어렵고, 런타임 에러를 유발할 가능성이 있음
    - (d)는 p2에 할당된 6워드 블록을 반환해준 상태
        - free 함수를 호출하여 블록을 반환하더라도 포인터 p2는 여전히 malloc된 블록을 가리킴
        - p2가 새로운 malloc 콜에 의해 다시 초기화될 때까지 p2를 사용하지 않음
        <img src="https://velog.velcdn.com/images/supssson/post/b54954a3-cf0c-42c1-9143-c29fa8836608/image.jpeg" height="150" width="500">

## 9.9.2 왜 동적 메모리 할당인가?
- 프로그램들이 동적 메모리 할당을 사용하는 가장 중요한 이유
    - 프로그램을 실제 실행시키기 전에는 자료 구조의 크기를 알 수 잆는 경우들이 존재
    - 예를 들어, n개의 정수 리스트를 라인마다 한 개씩 배열로 읽는 프로그램을 작성해야 한다고 하자
        - 입력은 정수 n과 읽고 배열에 저장해야 하는 n개의 정수로 구성
        - 가장 간단한 방법은 배열을 정해진 최대 배열 크기를 갖는 정적 배열로 정의하는 것
        ```C
        #include <csapp.h>
        #define MAXN 15213

        int array[MAXN];

        int main()
        {
            int i, n;

            scanf("%d", &n);
            if(n > MAXN)
                app_error("Input file too big");
            for(i = 0; i < n; i++)
                scanf("%d", &array[i]);
            exit(0);
        }
        ```
        - 위 코드처럼 배열을 정해진 크기를 사용해서 할당하는 것은 종종 나쁜 방법이 됨
            - MAXN 값은 임의로 정한 것으로, 실제 머신에서 가용한 가상메모리의 크기와는 무관
            - MAXN보다 더 큰 파일을 읽으려고 한다면, 프로그램을 더 큰 MAXN 값을 사용해서 컴파일하는 것이 유일한 대책
        - 더 나은 방법은 n 값을 알 수 있을 때 배열을 런타임에 동적으로 할당하는 것
            - 배열의 최대 크기는 가용한 가상메모리의 양에 의해서만 제한
            ```C
            #include <csapp.h>
        
            int main()
            {
                int *array, i, n;

                scanf("%d", &n);
                array = (int *)malloc(n * sizeof(int));
                for(i = 0; i < n; i++)
                    scanf("%d", &array[i]);
                free(array);
                exit(0);
            }
            ```

## 9.9.3 할당기 요구사항과 목표
- 명시적 할당기들은 다소 엄격한 제한사항 내에서 동작
- 요구사항
    - 임의의 요청 순서 처리하기
        - 응용프로그램은 각각의 가용 블록이 이전의 할당 요청에 의해 현재 할당된 블록에 대응되어야 한다는 제한사항을 만족하면서 임의의 순서로 할당과 반환요청을 할 수 있음
        - 따라서, 할당기는 할당과 반환 요청의 순서에 대해서는 아무 가정도 할 수 없음
    - 요청에 즉시 응답하기
        - 할당기는 블록들을 이들이 어떤 종류의 데이터 객체라도 저장할 수 있도록 하는 방식으로 정렬해야 함
    - 힙만 사용하기
        - 확장성을 갖기 위해서 할당기가 사용하는 비확장성 자료 구조들은 힙 자체에 저장되어야 함
    - 블록 정렬하기(정렬 조건)
        - 할당기는 블록들을 이들이 어떤 종류의 데이터 객체라도 저장할 수 있도록 하는 하는 방식으로 정렬해야 함
    - 할당된 블록을 수정하지 않기
        - 할당기는 가용 블록을 조작하거나 변경할 수만 있음
        - 블록이 할당되면 이들을 수정하거나 이동하지 않음
        - 따라서, 할당된 블록들을 압축하는 것 같은 기법들은 허용되지 않음
- 목표
    - 처리량 극대화하기
        - n번의 할당과 반환 요청의 배열이 주어졌을 때, 할당기의 처리량을 최대화하려고 하며, 이것은 단위 시간당 완료되는 요청의 수로 정의
        - 일반적으로, 할당과 반환 요청들을 만족시키기 위한 평균 시간을 최소화해서 처리량을 최대화 함
    - 메모리 이용도를 최대화하기
        - 한 시스템에서 모든 프로세스에 의해 할당된 가상메모리의 양은 디스크 내의 스왑 공간의 양에 의해 제한
        - 최고 이용도(peak utilization)
            - 할당기가 얼마나 힙을 효울적으로 사용하는지를 규정하는 방법 중에서 가장 유용한 단위
                <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRvzhk%2FbtqTF2K38h0%2FUOGkXByKJ2eOwd0dexNn60%2Fimg.png" height="50" width="100">
            - 간단하게 말하면, 이용도U = ( 실제로 사용하는 힙의 크기 = maxPi ) / ( 할당된 힙의 크기 = Hk )
            - 즉, U = 1이면 낭비되는 것 없이 힙을 온전히 그대로 사용하고 있고, U = 0 이라면 실제로 사용되는 힙이 없음에도 불구하고 힙이 할당되어 있는 것

## 추가정보. 단조성(monotonicaity) 가정의 완화
- Uk 정의에서 단조 증가에 대한 가정을 완화할 수 있음
- Hk를 처음 k + 1 요청에 대해 고점 표식으로 해서 힙이 증가하고 감소할 수 있도록 함

## 9.9.4 단편화(Fragmentation)
- 단편화
    - 메모리 공간이 작은 조각으로 나눠져 사용 가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태일 떄 발생
- 두 종류의 단편화
    - 내부 단편화
        - 할당된 블록이 요구하는 데이터보다 더 크게 할당되어 사용하는 메모리 공간을 낭비할 때 발생
        - 예를 들어, 아래 그림을 보자
            <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbfy5Je%2FbtqTIpMKXVU%2FNGzbVdi7cNZbyfjxxdrHW0%2Fimg.png" height="60" width="350">
            - 정수는 4바이트이므로 5 * sizeof(int)는 5칸을 차지 함
            - 하지만, 64바이트에서는 8바이트씩(2칸씩)만 배치할 수 있으므로 2의 배수로 할당해서 6칸을 차지 함
            - 따라서, 4바이트가 낭비되고 있는 상태
    - 외부 단편화
        - 